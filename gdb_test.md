# GDB

​	主要功能是监控程序的执行流程。这也意味着只有当源程序文件编译为可执行文件后，GDB才能派上用场。

```cc
g++ gdb.cc -Og//在可执行文件中加入调试信息
gdb a.out -q//不打印免责信息
b XXX(断点位置) 	(break)//设置断点
    
r(run)//运行到个断点，或执行结束
c(continue)    //继续执行遇到下一个断点或者执行结束
n    (next) //令程序一行行执行代码a执行时（会跳过调用的函数）
s    (step)//单步调试（会进入要执行的函数）
p  XXX(某个变量)    (print) 打印某个变量的值
l(list)    显示源码的内容包括代码的行号
q(quit)    终止调试
pidof //查看某个正在运行程序的pid
	gdb -p pid //对某个正在运行的程序进行调试（被调试程序会停止在某一行）     调试结束后需要用detach结束调试，然后q退出gdb。
core dump    //gcc *.cc -g  调试文件时生成带有调试信息的可执行文件，执行时若发生core dump会生成core文件，此时执行gdb ./a.out core 就能够找到发生core dump的位置。
    
    
    file	//为开启的gdb命令加载可执行文件
    cd 将gdb移动到某个文件的位置
    break	是普通断点   以下三种都可以称为条件断点
    watch	观察断点
    catch	捕捉断点
```

# Makefile

主要依靠依赖关系，make执行的是Makefile中的第一规则（Makefile中出现的第一个依赖关系），此规则的第一目标称为 “最终目标” 或者 “终极目标”。

```Makefile
.PHONY:clean
clean：
	rm -rf *.o test

目标文件：依赖文件
	~多个命令
	//只有目标文件比依赖文件旧时或目标文件不存在时才会执行命令
	//伪目标：以不会存在的文件名作为目标，make伪目标一定会执行
	.PHONY:clean rebuild
	clean:
		rm -f main.o add.o main
	rebuild:clean main
```

| 变量  | 说明                                       |
| :---- | ------------------------------------------ |
| $@    | 目标文件                                   |
| $<    | 第一个依赖文件                             |
| $^    | 所有依赖文件，以空格分隔                   |
| $?    | 日期新于目标文件的所有相关文列表，都好分割 |
| $(@D) | 目标文件的目录名部分                       |
| $(@F) | 目标文件的文件名部分                       |

%匹配字符

​	可以作为某个规则的目标（此目标是上一个规则的依赖文件），

​	%表达式根据变量内容生成新的内容

内置函数；

​	wildcard 从文件系统中根据通配符取出文件名。

​	`subst`

​	`patsubst` 

​	循环 for	in;

​			do	done;

​	



