**cpp**

1 c语言中的struct只能包含变量，而cpp中的class可以包含变量和函数；cpp中的struct也可以包含函数，struct成员默认public；class默认是private

2 面向对象编程的代码在执行效率上没有任何优势，主要是便于组织和管理代码，理清思路，带来思想上的革新。

3 命名空间：保留原来的库和头文件，他们在c++中可以继续使用，然后再把原来的库复制一份，在此基础上稍加修改，把类、函数、宏等纳入命名空间std下，就成了c++新版标准库，这样共存了两份功能相似的库，使用老式c++的程序可以使用原来的库，新开发的程序可以使用新版的c++库。

对于不带.h的头文件，所以符号都位于std中，使用时需要声明命名空间；对于.h头文件没有使用任何命名空间，所有文件都位于全局作用域。

4 直接讲std声明在所有函数外部，这样做回增加命名冲突的风险，尽量在函数内部声明std；

5 cout和cin都是内置对象而不是关键字。

6 const在c语言中，对const的处理和普通变量一样，会到内存中读取数据；c++中对const的处理是在编译时期进行替换；像编译时期的#define；

const在c++中的其他文件是不可见的，类似于static关键字；

7 c和c++中的全局const变量的作用域相同，都是当前文件，不同的是他们的可见范围，c语言中的const全局变量的可见范围是整个程序，在其他文件中使用extern声明后可以使用；而c++中的const可见范围仅限于当前文件，在其他文件中不可见，在其他文件中不可见，所以他可以定义在头文件中，多次应用才不会出错；

8 内联函数的两个作用；消除函数调用是的开销；取代带参数的宏；

***内存对齐的规则***

**为什么要内存对齐**

1）cpu对内存的读取不是连续的，而是分块读取的，

2）当读取操作的数据=未对齐时，需要两次总线周期来访问内存，因此性能会大打折扣；

3）某些平台只能从规定的相对地址读取特定类型的数据，否则会产生异常。

**1.1数据对齐规则**

第一个放在offset为0的地方，以后的数据成员对齐（存放位置的起始地址）按照#pragma pack（）和这个数据自身长度成员中较小的那个。

**1.2结构或联合整体的对齐规则**

数据对齐后，结构体按照#pragma pack（8）指定的数值和结构体或者联合体中最大数据成员中，比较小的那个进行。

**1.3结构体作为成员**

结构体要从其内部最大元素大小的整数倍地址开始存储。

》对齐规则是按照成员的声明顺序，依次安排内存，其偏移量为成员大小的整数倍，0可以看做任何成员的整数倍，最后结构体大小为最大成员的整数倍。



9 默认值指的是函数调用中省略了实参时自动使用的一个值，这个值就是给形参使用指定的默认值。

默认参数只能放在形参列表的最后，而且一旦指定了默认参数，他后面所有形参都必须有默认值；

c++规定在给定的作用域中只能指定一次默认参数；

10 参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫参数列表不同；（参数签名不同）

参数列表不同包括参数的个数不同。类型不同或者顺序不同，仅仅参数名称不同是不可以的，函数返回值也不能作为重载的依据。

函数重载仅仅是语法层面的，本质上他们还是不同的函数，占用不同的内存，入口地址也不一样。

11 类型提升和类型转换不是一回事，类型的提升是积极的，是为了更加高效的利用计算机硬件，不会导致数据丢失和精度降低；类型转换是不得已而为之，不能保证数据正确性，也不能保证应有的精度。

12 多参数时的二义性；该函数对每个实参的匹配都不劣于其他函数；

​										至少有一个实参的匹配犹豫其他函数；

13 exten “c”的两种用法。仅修饰一句时直接放到前面，修饰一段话时将后面的一段话用{}括起来

14 类只是一个模版，编译后1不占用内存，所以在定义时不能对成员变量进行初始化，

15 使用new在在堆上创建出来的对象时匿名的，没法直接使用，必须有一个指针指向他，在借助指针来指向他，在借用指针来访问他的成员函数和成员变量。（不使用时需要用delete释放申请的空间）

16 成员函数必须现在类体中声明，然后再类外定义，类体的位置应在函数定义之前。

17内联函数一般不是我们所期望的，他会将调用处用函数体替代，所以在类内部对成员函数进行声明，在类外对成员函数进行定义。这是一种良好的编程习惯，

18 成员访问限定符：public 、protected、private。

19 成员变量大都以m_开头，这是约定熟成的用法。

20 只被成员函数调用的成员函数声明为private，能被类调用的成员函数声明为public。

21 给成员变量赋值的函数通常称为set函数，他们的名字通常以set开头，后面跟成员变量的名字。

22 所谓封装就是尽量隐藏类的内部实现，只向用户提供有用的成员函数。

23 因为不同对象的成员变量可能不同，成员函数时相同的。所以编译器会将成员变量和成员函数分开存储；为每个成员变量分配内存，但是所有的对象都共享同一段函数代码。

24 通过传递对象指针就完成了成员函数和成员变量的关联。与我们从表面上看到的刚好相反，通过对象调用成员函数时，不是通过对象找函数。而是通过函数找对象。

25 构造函数的调用是强制性的，一旦类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的，入过有多个重载的构造函数，那么创建对象时提供的实参必须和其中一个构造函数匹配；反过来说创建构造函数只有一个构造函数1会被调用。

26 一个类必须有构造函数，有么自己定义要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个、形参如何，编译器都不能自动生成，

调用没有参数的构造函数也可以省略括号；

27使用构造函数在参数为类类型时效率较高，可以省去一次默认构造函数的时间；成员变量的初始化顺序和和初始化列表中列出的顺序无关，他只与成员变量在类中声明的顺序有关。

```cpp
Demo::Demo(int b):m_b(b),m_a(a){}
```

28 初始化const成员变量的唯一方法是使用初始化列表。

29 析构函数也是一种特殊的函数；没有返回值无法且不需要显示调用，而是在销毁对象时自动执行；

申请堆中内存时需要我们手动释放，所以要自己调用析构函数

```cpp
VAL::~VAL(){delte[] m_arr;}
```

30 一个类的成员变量是另一个类的对象，就称之为成员对象，包含成员对象的类叫封闭类；

31 this指针是成员函数的一个形参，在调用成员函数时将对象地址作为实参传递给this，不过这个this是隐式的，不出现在代码中而是由编译器在编译阶段将他默默添加到参数列表中。实际上this指针是成员函数和成员变量关系的桥梁。

33 静态成员变量实现实现多个对象共享数据的目标。static成员变量的内存分配既不是在声明类时分配，也不是在创建对象时分配。而是在类外初始化时分配。没有在类外初始化的static成员不能使用。

34 static成员不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也能访问。

35 静态成员函数和普通成员函数的根本区别在于：普通成员函数有this指针，可以访问类中的任意成员；而静态成员没有this指针，只能访问静态成员（包括静态成员函数和静态成员指针）；

**关于static的几点说明**

》一个类中可以有一个或者多个静态成员变量，所有的对象都可以共享这些静态成员变量，都可以引用他。

》static成员变量和普通static变量一样，都在内存分区中的全局数据区分配内存，到结束时释放，static成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存空间，在对象销毁时释放内存。

》静态成员变量必须初始化，而且只能在类体外进行，

```cc
int Student::m_total=10;
```

》静态成员变量可以同过对象名访问，也可以同过类名访问，但要遵循private，protected，public关键字的访问权限，铜锅对向名访问时，不同的对象访问的是同一块内存。

36 const必须在成员函数的声明和定义处同时加上const关键字。

​	const的位置不同代表不同的含义

​			函数开头的const用来修饰函数的返回值，表示返回值是const类型。

函数头部的结尾加上const表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值。

37 常对象；一旦将对象定义为常对象之后就只能调用类的const成员了；

39 借助友元可以使得其他类中的成员函数以及全局范围内的函数访问当前类的private成员。

40 友元函数有非成员函数和成员函数两类。友元函数不同于类的成员函数，在友元函数不能直接访问类的成员，必须要借助对象；

41 一般情况下。类必须在正式声明之后才能使用，但是某些情况下，只要提前做好声明，也可以先使用；

42 一般不建议把整个类声明为友元类，而是将某些函数声明为友元函数，这样更安全；

43 引用可以看做数据的一个别名，通过这个名字和原来的名字都能够找到这份数据，

引用必须在定义的同时初始化，并且要从一而终，不能在引用其他数据，这一点有点类似于常量（const变量）

44 引用只是对指针进行了简单的封装，他的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，

45 不是引用不占用内存，而是编译器不让获取他的地址。

46 常量表达式的值虽然在内存中，但是没有办法寻址，所以不能使用&来获取他的地址，更不能用指针指向他；

47 常引用绑定到零时数据时；编译器会为零时数据创建一个新的、无名的零时变量，并将零时数据放到该零时变量中，然后将引用绑定到该零时变量。编译器只有在必要的时候才会创建变量

48 给引用添加const限定后，不但可以将其绑定到零时数据，还可以将引用绑定到类型相近的数据，这使得引用更加灵活和通用，他们背后的机制都是零时变量。

***继承与派生***

49被继承的类称为父类或者基类，继承的类称为子类或者派生类。（inheritance）(derive)

50 这些继承过来的成员，可以可以通过子类对象访问就像自己的一样。

```cpp
class 派生类名：【继承方式】 基类名{
	派生类新增加的成员
}//继承方式 public private protected
```

51 继承关系中基类的访问权限不得高于继承方式中指定的权限。

52 实际上基类的private成员是能够被继承的，并且会占用派生类的内存，只是在派生类中不可见导致无法使用。

53 在派生类中访问基类private成员的唯一方法基类的非private成员函数，如果基类中没有非private成员函数，那么该成员在派生类中将无法访问。

54 using只能改变基类中public和protected成员的访问权限，不能改变private成员的访问权限，因为基类的private在派生类中不可见，根本不能使用，所以基类的private成员在派生类中无论如何都不能访问

55 cpp继承时存在名字遮蔽问题、基类成员和派生类成员函数不构成重载；

56 类也是一种作用域，作用域允许嵌套。被包含的作用域称为inner scope，包含着别的作用域称为外层次作用域（outer scope）

57 继承关系中的名字查找，在作用域链中寻找与所用名字最匹配的声明或定义过程。（查找成员函数时只匹配成员函数的名字）

58 在派生类的对象模型中，会包含所有基类的成员变量，这种设计的优点是访问效率高，能够在派生类中直接访问基类变量，不过要经过好几层中间计算；

59 类的构造函数不能被继承。对于基类中的private成员变量，可以在派生类的成员函数中调用基类的成员函数对其进行初始化；

60派生类只能直接调用基类的构造函数，不能调用间接基类的；

61 多继承会出现菱形继承产生歧义；

***虚继承***

62 虚继承的目的是让某个类作出声明，承诺愿意共享他的基类。其中这个愿意被共享的基类就被称为虚基类（virtual Base Class）.这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中只包含一份虚基类的成员。

63 必须在虚派生的真实需求出现以前完成虚派生的操作。

64 虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，不会影响派生类本身。

65 多继承可能会出现菱形继承等二义性问题；能用单一继承解决的问题就不需要用多继承。

66 虚继承D直接初始化基类A，直接派生类B和C对A的构造函数调用是无效的；

对于虚继承编译器总是先调用基类的构造函数；对于普通继承，就是按照构造函数出现的顺序依次调用；

67虚继承下的内存模型：因为c++标准仅对c++的实现做了框架性得描述，所以各家编译器在实现方面有所差异，虚继承的内存模式。

***虚继承内存模式***

对于虚继承和普通继承恰恰相反，大部分编译器会把基类成员变量放在派生类成员的后面，这样随着继承层级的增加，基类程远边梁的偏移就会改变，就必须通过其他方案计算偏移量。

（1）A,B,C,D中A是B的虚基类

```cpp
class B:virtual public A
```

![img](http://c.biancheng.net/uploads/allimg/190214/1G2255391-1.jpg)

(2) 在假设A是B的虚基类，B是C的虚基类；

![img](http://c.biancheng.net/uploads/allimg/190214/1G225C60-2.jpg)



从上面两张图可以发现虚继承是派生类对象被分成了两部分，：

：不带阴影的一部分非偏移量固定，不会随着继承层次的增加而改变，称为固定部分

：带有阴影的一部分是虚基类的子对象，偏移量会随着继承层次的增加而改变，称为共享部分；

（各家编译器共享部分都是放在最后）；

早起cfront的解决方案会在派生类对象中安插一些指针，每个指针指向一个虚基类的子对象，要存取继承过来的成员变量；

（1）如果A是B的虚基类，

![img](http://c.biancheng.net/uploads/allimg/190214/1G225G18-3.jpg)

（2）如果A是B的虚基类，同时B也是C的虚基类，

![img](http://c.biancheng.net/uploads/allimg/190214/1G2253452-4.jpg)

通过上面的的分析发现，这个方案的一个缺点是随着继承层次的增加，访问顶层基类需要的间接转换会越来越多，效率越来越低。

另一个缺点是，当有多个虚基类时，派生类会为每一个虚基类都安插一个指针，会增加对象的体积。

![img](http://c.biancheng.net/uploads/allimg/190214/1G2254127-6.jpg)

VC的解决方案是：引入虚基类表，如果某个派生类有一个或者多个虚基类，编译器会在派生类中安插一个指针，指向虚基类表。虚基类表其实就是一个数组，数组中存放的元素是各个虚基类的偏移。

A是B的虚基类，同时B是C的虚基类，

![img](http://c.biancheng.net/uploads/allimg/190214/1G2253H6-8.jpg)

不管继承多深都只需要一次间接转换。

A和B和C都是D的虚基类；

![img](http://c.biancheng.net/uploads/allimg/190214/1G2255133-10.jpg)

虽然有多个基类，但他的对象只需要额外背负一个指针；

***cpp向上转型***

类其实也是一种数据类型，也可以发生数据转换，不过这种转换只有在派生类和基类之间才有意义，并且只能将派生类复制给基类，包括将派生类对象复制给基类对象，将派生类指针赋值给基类指针，将派生类引用复制给基类引用，这在cpp中称为向上转型，（upcasting）。相应的将基类复制给派生类称为向下转型（downcasting）；

向上转型很安全，向下转型有风险。

赋值的本质是将现有的数据写入已分配好的内存，对象内存只包含了成员变量，所以对象之间的赋值是成员变量之间的赋值，成员函数不存在赋值问题。

派生类给基类赋值，这种转换关系是不可逆的，只能用派生类对象给基类对象赋值。

**将派生类指针赋值给基类指针**

编译器通过指针来访问成员变量，指针指向那个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类就使用哪个类的成员函数。（复制后可能出现值不一样的情况）；

像将double赋值给int一样，将派生类的指针赋值给基类的指针时也是同样的道理，编译器也可能会在赋值前进项处理。

对象的指针必须指向对象的起始位置。



**将派生类引用赋值给基类引用**

虽然使用了派生类的成员变量，但是没有使用他的成员函数，与指针类似。



**向上转型后通过基类的对象，指针，引用只能访问从基类继承过去的成员，不能访问派生类新增的成员**

***多态与虚函数***

virtual  Function

有了虚函数，基类指针指向基类对象时就使用基类的成员，指向派生类对象时就使用派生类成员的成员，换句话说，基类可以按照基类的方式来做事也可以按照派生类的方式来做事，他有多种形态，或者说有多种表现方式，称之为多态（polymorphism）

c++提供多态的目的：可以通过基类指针对对所有派生类的成员变量和成员函数进行全方位的访问，尤其是成员函数。如果没有多态我们只能访问成员变量。

借助引用也可以实现多态，不过引用不像指针这么灵活，指针可以随时改变指向，而引用只能指代固定的对象。所以多态多指指针。

虚函数的注意事项：

（1）只需要在虚函数的声明处加上virtual关键字，函数定义处可加可不加；

（2）为了方便可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽关系的同名函数都将自动成为虚函数；

（3）当在基类中定义了虚函数时如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。

（4)只有派生类的虚函数覆盖基类的虚函数（函数原型相同）才能构成多态，（通过基类指针访问派生类函数）。

（5）构造函数不能是虚函数。对于基类的构造函数它仅仅是在派生类构造函数中被调用，这种机制不同于继承。派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。

（6）析构函数可以声明为虚函数，而且有时候必须要声明为虚函数，

**构成多态的条件**

》必须存在继承关系

》继承关系中必须有同名的虚函数

》存在基类的指针，通过该指针调用虚函数

大部分情况下都应当将基类的析构函数声明为虚函数；

**cpp纯虚函数**

在cpp中可以将虚函数声明为纯虚函数：

```cpp
virtual 返回值类型 函数名（函数参数）=0；
```

纯虚函数没有函数体只有函数声明

包含纯虚函数的类称为抽象类（Abstract Class）无法创建对象；通常作为基类让派生类去实现纯虚函数，派生类必须实现纯虚函数才能被实例化。

抽象基类的霸王条款：抽象基类除了约束派生类的功能，还可以实现多态。

**关于虚函数的几点说明**

（1）一个纯虚函数可以使类称为抽象基类，但是抽象抽象基类除了包含纯虚函数还可以包含其他成员函数（虚函数或者普通函数）和成员变量。

（2）只有类中的虚函数才能被称为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。

**虚函数表精讲**

（1）如果该函数是非虚函数，那么编译器会根据指针的类型找到该函数；也就是说指针是哪个类的类型就调用哪个类的函数。

（2）如果该函数是虚函数，并且派生类有同名的函数遮蔽他，那么编译器会根据指针找到该函数，也就是说指针指向的对象属于那个类，就调用哪个类的函数。

**虚函数表原理**

如果一个类中包含了虚函数，那么在创建该类的对象时就会额外创建一个数组，数组中的每个元素都是虚函数的入口地址。不过数组和对象时分开存储的，为了将对象和数组关联起来，编译器还需要在对象中安插一个指针，指向数组的起始位置，这里的数组就是虚函数表（Virtual function table）,简写vtable.

各个类对象的内存模型：

![img](http://c.biancheng.net/uploads/allimg/190215/14431Q529-0.jpg)

单继承原理分析：

```cpp
(*(*(p+0)+0))(p);
```

》0是vfptr在对象中的偏移，p+0是vfptr的地址；

》*（P+0）是vfptr的值，而vfptr是指向vtable的指针，所以\*（p+0)也就是vtable的地址；

》display在vtable中的索引是0，所以（*（p+0）+0）也就是display（）的地址；

》知道了display的地址，（*（\*(p+0)+0)）(p)也就是对display的调用了，这里的p就是传递的实参，他会赋值给this指针。

多继承是分析复杂：尤其是有虚继承时。

```cpp
typeid运算符：获取类型信息
```

》对于简单的基本类型的数据，类型信息所包含的比较简单；

》对于类类型的数据（也就是对象），类型信息是指对象所属的类，所包含的成员，所在的继承关系等。

<font color='red'>类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作，该如何操作等，都由他的类型信息决定。</font>

```cpp
typeid(dataType)
typeid(expression)
```

typeid会把获取到的类型信息保存到一个type_info类型的对象里面，并返回常引用；

typeid的几个常用的成员函数：

》name（）用来返回类型的名字。

》raw_name（）用来返回名字的编码（name Mangling）算法产生的新名字；

》hash_code（）用来返回当前类型对应的hash值。

type_info类的声明；

**RTTI机制精讲**

C++的对象内存模型主要包含了一下几个方面的内容：

》如果没有虚函数也没有虚继承，那么内存模型中只有只有成员变量。

》如果类包含了虚函数，那么会额外添加一个虚函数表，并在对象内存中插入一个指针，指向这个虚函数表。

》如果包含了虚继承，那么会额外添加一个虚基类表，并在内存中插入一个指针，指向这个虚基类表。

如果有虚函数，该类的对象中还会额外增加type_info对象，

![img](http://c.biancheng.net/uploads/allimg/190215/14461RX1-0.jpg)

编译器会在虚函数表vftable的开头插入一个指针指向type_info对象。当程序在运行阶段获取类型信息时，可以通过对象指针p找到虚函数表指针vfptr，在通过vfptr找到type_info对象的指针，进而取得类型信息。

```cpp
**(p->vfptr-1)
```

程序做好的准备：
》创建type_info对象，并在vftable的开头插入一个指针，指向type_info对象。

》将获取的类型信息的操作转换为**（p->vfptr-1）这样的语句。

代价是占用内存变高效率变低。

这种在程序运行后确定对象的类型信息的机制称为运行时类型识别（Run-Time Type Identification, RTTI);只有类中包含了虚函数才会启用RTTI机制，其他情况都可以在编译阶段确定其类型信息。

**静态绑定到动态绑定，彻底理解多态**

CPU访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行文件后他们都会被替换成地址。编译和链接过程的一个重要任务就是找到这些名称所对应的地址。

将变量名和函数名统称为符号（Symbol）。找到符号对应的地址的过程称为符号绑定。

**函数绑定**

找到函数名对应的地址，然后将函数调用处用改地址替换，这称为函数绑定。

》编译链接期间完成函数绑定的称为静态绑定（static binding）；

》编译期间不能确定使用哪个函数，必须等到程序运行后根据具体环境或者用户操作才能决定的称为动态绑定（dynamic binding）；

》动态绑定的本质：编译器在编译期间不能确定指针指向哪个对象，只能等到程序运行后根据具体情况在决定。

**继承链：要在基类和派生类之间增加一条绳索，把他们连起来，形成一条通路，让程序在各个对象之间游走。**

```cpp
class A{
protected:
    int a1;
public:
    virtual int A_virt1();
    virtual int A_virt2();
    static void A_static1();
    void A_simple1();
};

class B{
protected:
    int b1;
    int b2;
public:
    virtual int B_virt1();
    virtual int B_virt2();
};

class C: public A, public B{
protected:
    int c1;
public:
    virtual int A_virt2();
    virtual int B_virt2();
};
```



![img](http://c.biancheng.net/uploads/allimg/190215/144S01059-0.jpg)

***c++运算符重载***

》同一个运算有不同的功能（operator overloading）

》运算符重载时通过函数实现的，他本质时函数的重载

```
返回值 operator 运算符名称（形参列表）{
	//TODO
}
```

》运算符重载除了函数名有有特定的格式，其他地方和函数没有什么区别。

**类中的运算符重载**

```
//c3=c1+c2
c3=c1.operator+(c2)
//c1是要调用函数的对象，c2是函数的实参
```

```cpp
//实现运算符重载
complex complex::operator+(const complex &A) const{
    complex B;
    B.m_real=this->m_real+A.m_real;
    B.m_imag=this->m_imag+A.m_imag;
    return B;
}
//实现运算符重载的简练形式
complex complex::operator+(const complex &A)const{
    return complex(this->m_real+A.real,this->imag+A.imag);
}
```

return 语句中的complex（this->m_real+A.m_real,this->imag+A.imag）会创建一个零时对象，这个对象没有名称，是一个匿名对象，在创建零时对象过程中调用构造函数，return语句将零时对象作为函数返回值。

**全局内重载运算符**

》运算符重载函数不仅仅可以作为类的成员函数，也可以作为全局函数。

```cpp
//声明为友元类
friend complex operate+(const complex &A,const complex &A);
```

```cc
//在全局范围内重载+
complex operator+(const complex &A,const complex &B){
    complex C;
    C.m_real=A.m_real+B.m_real;
    C.m_imag=A.m_imag+B.m_imag;
    return C;
}
```

》运算符重载函数不是complex类的成员函数，但是却用到了complex类的private成员变量，所以必须在complex类中将该函数声明为友元函数。

```cc
c3=operator+(c1,c2);
```

》运算符重载的注意事项，

（1）并不是所有的运算符都可以重载。能够重载的运算符

```cc
+	-	*	/	%
+=	-=	*=	/=	%=	
^ 	&	|	~	!		<	>	
^=	&=	|=	<<	>>
    		<<=	>>=	==	!=	<=	>=
&&	||	
++ --	->*		new	new[] delete delete[]
-> ()	[]	=  只能以成员函数的方式进行重载
```

长度运算符sizeof，调减运算符：？ 成员选择符.   	和域解析符：：

不能被重载

(2)重载不能改变运算符的优先级和结合性。

3）重载不会改变运算符的用法，原有几个操作数，操作数在左边还是右边，都不会改变。

4)运算符重载不能有默认的参数，否着就改变了运算操作符的个数，

5）运算符重载函数既可以作为类的成员函数，也可以作为全局函数。

》将运算符重载作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，因为这个参数是隐含的，

```
//c3=c1+c2;
c3=c1.operator+(c2);
```

通过this指针隐式的访问c1的成员变量

》将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要有个参数，而且有一个必须是对象，以便区分需要重载的功能。防止程序员修改用于内置类型的运算符性质。

**以成员函数还是以全局函数（友元函数）重载**

》转换构造函数

```cc
complex(double real):m_real(real),m_imag(0.0){}//转换构造函数
```

在作为普通的构造函数的同时，还能将double类型转换为Complex类型，集合了构造函数和类型转换的功能，所有被称为【构造转换函数】。换句话说转换构造函数可以用来将其他类型（可以是bool,int,double等基本类型，也可以是数组，指针，结构体，类等构造类型）转换为当前类类。

**为什么要以全局函数的形式重载+**

》这样做是为了保证+运算符的操作数能被正确处理；能够对称的处理数据。

如果是以成员函数重载

```cc
//complex c2=c1+15.6
complex c2=c1.operator+(Complex(15.6));
```

这就是通过对象调用成员函数，是正确的但是

```cc
//Complex c3=28.23+c1;
Complex c3=(28.23).operator+(c1);//error
```

c++只会对成员函数的参数进行类型转换，而不会对调用成员函数的对象进行类型转换。

**为什么要以成员函数的形式重载+=**

运算符重载的初衷是给类添加新的功能，方便类的运算，他作为类的成员函数时应当的，是首选的。

```cc
Complex c3=complex(28.23)+c1;//全局形式
```



```cc
c++规定，箭头运算符->、下标运算[]、函数调用运算()、赋值运算=只能以成员函数的形式重载。
```

**重载输入运算符>>**

```cc
istream & operator>>(istream &in,complex &A){//全局重载
    in>>A.m_real>>A.m_imag;
    return in;
}
```

**重载输出运算符**

```cc
ostream & operator<<(ostream &out,complex &A){//全局重载
    cout<<A.m_real<<"+"<<A.m_imag<<"i";
    return out;
}
```

```cc
friend istream & operator>>(istream & in ,complex &a);//友元函数
//operator<<(cin,c);
```

**下标运算符[ ]**

下标运算符[ ]必须以成员函数的形式进行重载。

```cc
返回值类型 & operator[](参数)；
const 返回值类型 & operator[](参数) const；
 //因为const对象只能调用const成员，所以要两种形式都有；
```

```cc
operator++()实现自增的前置运算；
operator++(int n)实现后置运算；
```

 ```cc
stopwatch stopwatch::operator++(int n){//int n没有意义，只是为可区分前置还是后置；
    stopwatch s=*this;
    run();
    return s;
}
 ```

**new和delete**

》在重载new或者new[]时，无论是作为成员函数还是作为全局函数，他的第一个参数必须是size_t类型。

***C++模板***

**函数模板**

》在C++中，数据的类型也可以通过参数来传递，在函数定义时也可以不指明具体的数据类型，当函数发生调用时编译器可以根据实参自动推断数据的类型，这就是类型的参数化。

》一旦定义了函数模板，就可以将类型参数用于函数定义和函数声明了。说的直白一点，原来的int，float，char等内置类型的地方，都可以用参数来替代。

```cc
template < typename 类型参数1，typename 类型参数2，...>
返回值类型 函数名(形参列表){
}
```

```cc
templat<class T> void Swap(T &a,T &b){
    T temp=a;
    a=b;
    b=temp;
}
```

**类模板**

一旦声明了类模板，就可以将类型参数用于类的成员函数和成员变量。

```
模版头和类头是一个整体，可以换行，中间不能有分号。
```

 模板所支持的类型是宽泛的，没有限制的，我们可以使用任意类型来替换，这种编程方式称为泛型编程（generic programming）。（standard template library）

》交换两个数组唯一的办法就是逐个交换所有的数组元素，

```cc
template<typename T> void Swap(T a[],T b[], int len){
    T temp;
    for(int i=0;i<len;++i){
        temp=a[i];
        a[i]=b[i];
        b[i]=temp;
    }
}
```

**类模板创建对象时，程序员需要显示的指明实参**

**函数模板不需要显示指明实参，能够自动推断。**

》根据模板函数实参确定模板实参的过程称为模板实参推断。

》普通函数可以进行安全的类型转换，模板函数只能进行const转换、数组和函数指针转换，其他的都不能用于函数模板。

**模板实参推断过程中的类型转换**

```cc
template<typename T> void func1(T a,T b);
template<typename T> void func2(T *buffer);
template<typename T> void func3(const T & stu);
template<typename T> void func4(T a);
template<typename T> void func5(T &a);
```

具体调用形式：

```cc
int name[20];
Student stu1("zhanghua",20,96.5)//创建一个student 对象
    func1(12.5,30);//error
func2(name);//name的类型从int[20]转换为int*，所以T的真实类型为int
func3(stu1)//非const转换为const，T的真实类型为Student
func4(name);//name的类型从int[20]转换为int*，所以T的真实类型为int*
    func5(name);//name的类型依旧是int[20],不会转换为int*，所以T的真实类型为int[20];
```

```当函数形参是引用类型时，数组不会转换为指针
当函数形参是引用类型时，数组不会转换为指针
```

**函数模板的显式具体化**

》模板中的语句不一定能适用所有的类型，可能会有个别的类型没有意义，或者会导致语法错误。比如比较类和结构体的大小，或者指针的大小；

》显示具体化（explicit specialization）

```cc
//函数模板的显示具体化（针对STU类型的显示具体化）
template<> const STU& Max<STU>(const STU& a, const STU& b);
```

本例中。STU结构体用来表示一名学生，他有三个成员，分别是name,age,score,Max（）函数用来两份数据中较大的一份。我们不得不借助模板的显示具体化的声明，Max（STU）表明了要将参数类型T具体化为STU，原来使用T的位置都用STU替换，包括返回值类型形参类型，局部变量类型。

```cc
//MAX<STU>可简写为MAX，函数形参依经表明这是STU的一个具体化
template<> const STU& MAX(const STU& a,const STU& b)  ;
```

**函数调用规则**

》在cpp中，对于给定的函数名，可以有非模板函数、模板函数、显示具体化模板函数以及他们的重载版本，在调用函数时，显示具体化优于常规模板，而非模板函数优于显示具体化和常规模板。

**类模板的显示具体化**

```cc
#include <iostream>
using namespace std;

//类模板
template<class T1, class T2> class Point{
public:
    Point(T1 x, T2 y): m_x(x), m_y(y){ }
public:
    T1 getX() const{ return m_x; }
    void setX(T1 x){ m_x = x; }
    T2 getY() const{ return m_y; }
    void setY(T2 y){ m_y = y; }
    void display() const;
private:
    T1 m_x;
    T2 m_y;
};

template<class T1, class T2>  //这里要带上模板头
void Point<T1, T2>::display() const{
    cout<<"x="<<m_x<<", y="<<m_y<<endl;
}

//类模板的显示具体化（针对字符串类型的显示具体化）
template<> class Point<char*, char*>{
public:
    Point(char *x, char *y): m_x(x), m_y(y){ }
public:
    char *getX() const{ return m_x; }
    void setX(char *x){ m_x = x; }
    char *getY() const{ return m_y; }
    void setY(char *y){ m_y = y; }
    void display() const;
private:
    char *m_x;  //x坐标
    char *m_y;  //y坐标
};

//这里不能带模板头template<>
void Point<char*, char*>::display() const{
    cout<<"x="<<m_x<<" | y="<<m_y<<endl;
}

int main(){
    ( new Point<int, int>(10, 20) ) -> display();
    ( new Point<int, char*>(10, "东京180度") ) -> display();
    ( new Point<char*, char*>("东京180度", "北纬210度") ) -> display();

    return 0;
}
```

**部分显示具体化**

》部分显示具体化只能用于类模板，不能用于函数模板。

```cc
template<class T1, class T2>  //这里需要带上模板头
void Point<T1, T2>::display() const
    
    //类模板的部分显示具体化
template<typename T2> class Point<char*, T2>
```

**C++模板中的非类型参数**

```cc
template<typename T, int N> class Demo{ };
template<class T, int N> void func(T (&arr)[N]);
```



**C++模板的实例化**

由模板生成函数或类的国产叫模板的实例化（Instantiate）；

针对某个类型生成特定版本的函数或者类叫模板的一个实例；

》模板可以看成编译器的一组指令，他命令编译器生成我们想要的代码。

》类模板的成员函数，被调用才会实例化，不被调用永远不会实例化，这说明类的实例化是延迟的，局部的，编译器并不着急生成所有的代码。

》通过类模板创建对象时，一般只需要实例化成员函数和构造函数；初始化成员函数知道内存大小，初始化构造函数，知道如何初始化；

**C++模板用于多文件编程**

》通常将函数声明放在（.h)头文件中，将函数定义放在(.cpp)文件中。

》正是有了链接器的存在函数的声明和定义的奋力菜得以实现。

》总的来说，不管是函数还是类，声明和定义的分离其实是一回事，都是把函数的定义放到其他文件中，最终要解决的问题也就一个，就是把函数调用和函数定义对应起来（找到函数调用的地址，并填充到函数调用处），而保证这项工作完成的就是链接器。

》事实证明早模板中将函数德定义和声明分开放是不对的，程序员惯用的做法是将模板的声明和定义都放到头文件中。

模板的三大特征：

1）模板的实例化是按需进行的，

2）模板的实例化是由编译器完成的；而不是链接器；

3）在实例化过程中需要知道模板的所有细节，包含声明和定义。









**C++类模板与继承详解**

》类模板从类模板中派生

》类模板从模板类中派生

》类模板从普通类派生

》普通类从类模板派生

**C++类模板与友元**

》函数，类，类的成员函数作为类模板的友元

类模板实例化时，除了类型参数被替换其他的还保持原样，因此任何从Temp1得到的实例化包含友元声明；

》函数模板作为类的友元

》类模板作为类模板的友元

**C++类模板中的静态成员**

》类模板中可以定义静态成员，从该类模板实例化得到的所有类都包含同样的静态成员。类模板是类的上层，由类模板到具体类时，每个类都有自己的静态成员函数，但是这并不违反一个类的所有对象，共享一个静态变量

***C++面向对象进阶***

**C++拷贝构造函数**

严格来说，对象的创建包括两个阶段：首先要分配内存空间，然后进行初始化：

》分配内存很好理解就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候内存还比较 “原始” ，没有被 “教化” ，它所包含的数据一般是零值或者随机值，没有实际意义。

》初始化是首次堆内存赋值，让他有数据意义，注意是首次赋值再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算等。说白了就是调用构造函数。

很明显，这里的拷贝是在初始化阶段进行的，也就是用其他对象的数据来初始化新对象的内存。

```cc
//拷贝构造函数
Student(const Student &stu)
```

1)为什么必须是当前类的引用？

如果拷贝构造函数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，这个过程会一直进行下去。

2）为什么要是const引用？

拷贝构造函数只是初始化对象，并不会其他对象的数据，添加const，语义更明显；

添加const之后，可以将可以接收const对象和非const对象的传参。

默认拷贝是浅拷贝；

**拷贝构造函数的调用时机**

》旧对象对新对象赋值

》形参与实参匹配

》函数返回值是对象

**C++拷贝赋值函数**

》operator=（）的返回值类型为Array & ，这样不但能够避免在返回数据时调用拷贝构造函数，还能达到连续赋值的目的；

》if（this！=&arr）语句的作用是【判断是否会给同一个对象赋值】：如果是那就直接返回，如果不是，那就将原有对象的所有成员变量赋值给新对象，并对新对象重新分配内存。

》return *this；（表示返回当前对象）。

》operator=（）的形参为const Array & 这样不但能在传参时调用拷贝构造函数，还能同时接收const和 非const类型的实参，

》赋值运算符重载函数除了能有对象引用这样的参数之外，还能有其他参数，但是必须给出默认值；

```CC
Array & operator=(const Array &arr,int a=100);
```

**C++拷贝控制操作（三五法则）**

》由于拷贝控制操作是由三个特殊成员来完成的，所以我们称此为  *c++三法则*   在c++11中又增加了移动构造函数和移动赋值函数，称为*称为c++五法则*

》如果我们不定义这些拷贝控制成员，编译器会自动为他定义默认的操作，因此忽略这些拷贝控制函数，但是对于一些特殊资源（例如动态内存的分配，打开的文件，指向其他数据的指针，网络连接等）的类来说，依赖这些默认的操作会导致灾难，我们必须显示的定义这些操作。

**需要析构函数的类也需要拷贝和赋值操作**

**需要拷贝操作也需要赋值操作反之亦然**

**C++转换构造函数：将其他类型转换为当前类型**

》不同数据之间可以相互转换，无需用户指明如何转换的称为自动转换（隐式转换），需要用户显示指明如何转换的称为强制类型转换。

*转换转换构造函数*

将其他类型转换为当前需要的类型1需要借助转换构造函数（Convertion constructor）。

》需要注意的是为了获取目标类型，编译器会“不折手段”，会综合使用内置类型转换和用户自定义的转换类型的规则，并且会进行多级转换。

*构造函数*：默认构造函数，普通构造函数，拷贝构造函数；转换构造函数；

**对Complex类进行进一步的精简**

两个普通构造函数和转换构造函数可以合为一个构造函数：借助函数默认参数：

```cc
Complex（double 0.0，double image=0.0，）：m_real（real），
    m_imag（image）{}
```

```cc
//例子
int main(){
    Complex a(10.0, 20.0);  //向构造函数传递 2 个实参，不使用默认参数
    Complex b(89.5);  //向构造函数传递 1 个实参，使用 1 个默认参数
    Complex c;  //不向构造函数传递实参，使用全部默认参数
    a = 25.5;  //调用转换构造函数（向构造函数传递 1 个实参，使用 1 个默认参数）
    return 0;
}
```

*C++类型转换函数将当前类转换为其他类类型*

**类型转换函数**

语法格式：

```cc
operator type(){
    //TODO:
    return data;
}
```

operator 是C++的关键字，type是要转换的目标类型，data是要返回的数据。

》类型转换函数看起来没有类型转换函数，其实是隐式的指明了返回值类型。

*关于类型转换函数的说明*

》type可以是内置类型，类类型以及由typedef定义的类型别名，任何可作为函数返回类型的类型（void除外）都能够支持，一般而言，不允许转换为数组或者函数类型，转换为指针类型或者引用类型是可以的。

》类型转换函数可以被继承可以是虚函数

》一个类虽然可以有多个类型转换函数，但是多个类型转换函数要转换的目标本身又可以相互转换（类型相近），那么有时会产生二义性。

*转换构造函数和类型转换函数是相反的，有时会产生二义性，大多数是指定以转换构造函数*

****

所谓类型转换就是对数据所占用的二进制位进行从新解释。在作出从新解释的时候，隐式转换不仅会改变解释方式，而且可能会根据转换规则改变二进制位的内容；但是强制转换没有内置转换规则。所以只会改变解释方式，不会修改内存内容。这是隐式转换和强制转换的根本区别。（修改的并不是原始数据，而是副本）；

***类型转换的本质***

修改二进制位非常重要，他能把数据调到正确的值，所以这种修改时长会发生：

1）正数和浮点数在内存中的存贮形式大相径庭，将浮点数f赋值给整数i时，不能原样拷贝f的二进制位，也不能截取部分二进制位，必须先将f的二进制位读取出来，以浮点数的形式呈现，然后截掉小数部分把剩下的整数部分在转换成二进制，拷贝到i所在的内存中。

2）short一般占用两个字节，int一般占用2个字节，将short类型s赋值给int类型的i时，如果仅仅将s的二进制位拷贝给i那么最后两个字节会原样保留，，显然是错误的。

3）当类存在多重继承时，如果把派生类指针pd赋值给基类指针pb就必须考虑基类基类子对象在派生类中的偏移，偏移不为零是就要调整pd的值，这样赋值后才能让pb恰好指向基类子对象。

4）Complex类型占用16个字节，double占用8个字节，将double类型的数据赋值给Complex类型的变量（对象）时，必须调用转换构造函数，否着剩下的8个字节，就不知道如何填充了

》隐式转换必须发使用已知的转换规则，虽然灵活性受到了限制，但是由于能对数据进行恰当的调整，所以更加安全（几乎没有风险）。强制转换类型能够对更大的范围内数据类型间进行强制转换，例如不同类型指针（引用）之间的转换，从const到非const的转换，从int到指针的转换（有些编译器也允许指针到int的转换）等。这虽然增加了灵活性。但是由于不能恰当的调整数据，所以也充满了风险，程序员要小心使用。

》隐式类型转换和显式类型转换最根本的区别是：隐式类型转换除了会重新解释二进制位，还会李勇已知的转换规则对数据进行恰当的调整；二显式类类型只能简单粗暴的重新解释二进制位不能对数据进行任何调整。

**强制转换不是万能的**

》类型转换只能发生在相关类型或者相近类型，两个毫不相关的类型不能相互转换，即使使用强制转换也不行。例如：两个没有继承关系的类不能相互转换，基类不能像派生类转换（向下转型），类类型不能向几本类型转换，指针和类类型之间不能相互转换。

**C++ static_cast、dynamic_cast、const_cast和reinterpret_cast**

| 关键字           | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| static_cast      | 用于良性转换，一般不会导致意外发生，风险很低。               |
| const_cast       | 用于 const 与非 const、volatile 与非 volatile 之间的转换。   |
| reinterpret_cast | 高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。 |
| dynamic_cast     | 借助 RTTI，用于类型安全的向下转型（Downcasting）。           |

》static_cast只能用于良性转换，这样的转换风险低，

原有类型的自动转换；

void指针和具体类型指针之间的转换，

有构造函数或者类型转换函数的类与其他类型之间的转换；例如double转为Comolex（调用转换构造函数）。complex转double（调用类型转换函数）。

**不能用于**

个具体指针之间的转换，例如int*转double*（不同类型的数据存储格式不一样，长度也不一样）

int 和指针之间的转换；

static_cast也不能用来去掉表达式的const修饰和volatile修饰》

**const_cast关键字**

用来将const、volatile类型转换为非const、volatile类型。

C++对常量的处理方式在编译期间就对其值进行了替换。

**reinterpret_cast关键字**

reinterpret是重新解释的意思，仅仅是对二进制位进行重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。

**dynamic_cast关键字**

dynamic_cast用于在类的继承层次之间进行类型转换，他即允许向上转型也允许向下转型（Downcasting）。向上转型是无条件的，安全的，不进行检查的，向下转型的前提必须是安全的，要借助RTTI进行检测，所以只有一小部分会成功。

dynamic_cast只能转换指针类型和引用类型；

**向下转换**

当使用dynamic_cast对指针进行类型转换的时候，程序首先会找到该指指向的对象，在根据对象招到当前类（指针指向的对象所属的类）的类型信息，并从此节点开始沿着继承链向上遍历，如果找到了要转换的目标类型，哪么说明这种转换是安全的，就能转换成功，如果没有找到要转换的目标类型，那么说明这种转换风险较大，就不能转换。

***C++17***

**auto**

* auto关键字的用法

  ```cc 
  auto name = value
  ```

auto仅仅是一个占位符，在编译期间会被真正的类型替代。

使用auto类型推导的变量必须马上赋值。

auto与const的用法；

当类型不为引用时，auto的推导结果将不保留表达式的const属性

当属性为引用时，auto的推导结果将保留表达式的const属性

**auto的限制**

》auto不能在函数的参数中使用。

》auto不能作用于类的非static变量成员；

》auto关键字不能定义数组

》auto不能用于参数模板

**auto的应用**

》auto用来定义STL的迭代器。在使用STL迭代器的时候，需要使用迭代器来遍历容器里面的元素；不同容器的的迭代器有不同的类型，在定义迭代器时必须指明。而迭代器的类型有时候比较复杂。

**auto用于泛型编程**

当我们不知道变量是什么类型或者不希望指明具体类型的时候。

**C++ decltype类型推导完全攻略**

》decltype是“ declare type”的缩写，“ 声明类型”；

```cc
auto varname = value;
decltype(exp) varname= value;
```

》auto根据=右边的·初始值value推导出变量的类型，而decltype根据表达式推导出变量的类型，跟等号右边的value值没有关系。

```cc
decltype(exp) varvalue;
```

**exp注意事项**

原则上说，exp就是一个普通的表达式，他可以是任意复杂的形式，但是我们必须保证exp的结果是有类型的，不能是void；

**decltype推导准则**

》如果exp是一个不被括号（）包围的表达式，或是一个类成员访问表达式，或是一个单独的变量，那么decltype（exp）的类型就和exp一致。这是最普遍最常见的情况。

》如果exp是函数调用，那么decltype（exp）的类型和函数返回值类型一样

》如果是一位左值或者被括号包围，decltype（exp）就是exp的引用。

**auto和decltype的比较**

auto将变量的类型和初始值绑定在一起，而decltype将变量的类型和初始值分开；虽然auto更简单但是decltype更加灵活。

**对CV限定符的处理（const和volatile）**

* const关键字是用来表示数据是只读的也就是不能被修改；

* volatile和const相反，他用来表示数据是可变的，易变的，目的是不让CPU将数据缓存到寄存器，而是从原始内存中读取。

* 如果表达式的类型时引用或者指针，auto会保留cv限定符，否着抛弃

  decltype不会抛弃表达式的CV属性；

  **对引用的处理**

  当表达式为引用时，auto和decltype的推导规则也不一样；

  decltype会保留引用类型，而auto会抛弃引用类型，直接推导出他的原始类型；

  表达式不复杂时使用auto，表达式复杂时使用decltype。

  **C++返回值类型后置**

  有时候通过参数的运算得到返回值的类型。

  前置返回类型的泛型编程

  ```cc
template <typename T, typename U>
  decltype((*(T*)0) + (*(U*)0)) add(T t, U u)
  {
      return t + u;
  }
  ```
  
  
  
  》C++的返回值是前置语法，在返回值定义的时候参数变量还不存在。
  
  返回类型后置语法（trailing-return-type），是了解决函数返回值依赖于参数而导致难以确定返回值类型的问题，有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数运算做出来）描述出来。
  
  后置返回值类型（trailing-return-type）
  
  ```cc
  template <typename T, typename U>
  auto add(T t, U u) -> decltype(t + u)
  {
      return t + u;
  }
  ```
  
  **C++11对模板实例化中连续右尖括号的改进**
  
  模板实例化有一个很繁琐的地方，那就是两个右尖括号（>>）会被编译器解释成右移操作运算符，而不是模板参数表的结束。
  
  **C++中使用using定义别名**
  
  因为typedef无法定义一个模板，所以就可以使用using。在重定义普通类型上两者是完全一样的，唯一不同的是定义语法，
  
  ```cc 
  typedef void (*func_t)(int,int);
  ```
  
  
  
  》typedef定义方法和变量的声明类似：向声明一个变量一样，声明一个重定义类型，之后在声明之前加上typedef即可。
  
  using后面重是立即跟随新标识符（identifier），之后使用赋值的语句，把现有的类型（type-ID）赋给新的类型；
  
  ```cc
  using func_t = void (*)(int,int);
  ```
  
  **C++11支持函数模板的默认模板参数**
  
  》总的来说，C++11支持为函数模板中的参数设置默认值，在实际使用过程中，我们可以选择使用默认值，也可以由编译器自行推导得到，还可以亲自指定各个模板参数的类型；
  
  》当所有模板参数都有默认参数时，函数模板的调用就如同一个普通函数。但对于模板类而言，哪怕所有的参数都有默认参数，在使用时也必须在类模板后面跟	< >	来实例化。
  
  》当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变的异常灵活。我们可以指定函数中一部分模板参数采用默认参数，而另一部分使用自动推导。
  
  》当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数既无法推导出来右为设置其默认值，则编译器直接报错。
  
  **C++11列表出初始化（同一了解初始化方式）（List-initialization）**
  
  POD类型时plain old data 类型，简单来说，是可以直接使用memcpy复制的对象。可以直接使用	{ }	进行初始化。
  
  **C++lambda匿名函数用法介绍**
  
  匿名函数被称为lambda函数或lambda表达式。
  
  》lambda匿名函数的定义
  
  ```cc
  [外部变量访问方式说明符] (参数) mutable noexcept/throw()->返回值类型
  {
   	函数体；  ;
  };
  ```
  
  其中个部分的含义：
  
  1）[外部变量方位方式说明符	 ]	 
  
  [	]方括号用于像编译器表明当前是一个lambda表达式，其不能被省略。在方括号内部，可以注明当前lambda函数的函数体中可以使用那些"外部变量"
  
  * 所谓外部变量，指的是当前lambda表达式位于同一作用域内的所有局部变量。
  
    2）（参数）
  
    和普通函数定义一样，lambda匿名函数也可以接收外部传递的多个参数。和普通的函数不同的是，如果不需要传递参数，可以连同（）一起省略。
  
  3）mutable
  
  此关键字可以省略，如果使用者之前的（）小括号将不能被省略（参数个数可以为0）。
  
  默认情况下，对于以值传递方式引入的外部变量，不允许在lambda表达式内部修改他们的值（可以理解为这部分变量都是const常量）。而如果想修改他们，必须使用mutable关键字。
  
  
  
  注意：对于以值传递的方式引入外部变量，lambda表达式修改的是拷贝的那一份，并不会修改真正的外部变量；
  
  4）noexcept/throw()
  
  可以省略，如果使用，在之前的（）小括号将不能省略（参数个数可以为0）。默认情况下，lambda函数的函数体中可以抛出任何类型的异常。而标注noexcept关键字，则表示函数体内不会抛出任何异常。使用throw（）可以指定lambda函数内部可以抛出的异常类型。
  
   值得一提的是，如果lambda函数标有noexcept而函数体内抛出了异常，又或者使用throw（）限定了异常类型而函数体内抛出了非指定的异常，这些异常将无法被try-catch捕获，会导致程序运行失败。
  
  5）->返回值类型
  
  指明了lambda匿名函数的返回值类型。值得一提的是，如果lambda函数体内只有一个return语句，或者该函数返回void，则编译器可以自行推断返回值的类型，此情况下可以直接省略->返回值类型。
  
  6）函数体
  
  和普通函数一样，lambda匿名函数包含的内部代码都放置在函数体中。该函数除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量和全局范围内的所有全局变量。
  
  | 外部变量格式      | 功能                                                         |
  | ----------------- | ------------------------------------------------------------ |
  | []                | 空方括号表示当前 lambda 匿名函数中不导入任何外部变量。       |
  | [=]               | 只有一个 = 等号，表示以值传递的方式导入所有外部变量；        |
  | [&]               | 只有一个 & 符号，表示以引用传递的方式导入所有外部变量；      |
  | [val1,val2,...]   | 表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序； |
  | [&val1,&val2,...] | 表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序； |
  | [val,&val2,...]   | 以上 2 种方式还可以混合使用，变量之间没有前后次序。          |
  | [=,&val1,...]     | 表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。 |
  | [this]            | 表示以值传递的方式导入当前的 this 指针。                     |
  
  >  注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。

**C++11非受限联合体**

联合体（union）是一种构造数据类型。

C++11规定任何非引用类型都可以成为联合体的数据成员，这种联合体成为非受限联合体。

**POD类型**

一般具有如下几种特征：

1）没有用户自定义的构造函数，析构函数，拷贝构造函数和移动1构造函数。

2）不能包含虚函数和虚基类。

3）非static成员必须声明为public。

4）类中的第一个非静态成员类型与基类不同。

```cc
class B1{};
class B2:B1{B1,b};
```

class B2的第一个非静态成员b是基类类型，所以不是POD类型。

5）在类或结构体继承时，满足以下两种情况之一：

* 派生类中又非静态成员，且只有一个仅包含静态成员的基类；
* 基类有非静态成员而派生类没有非静态成员。

6）所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说POD类型，不能包含非POD类型。

7）所有兼容c语言的数据类型都是POD类型。

```cc
placement new的语法格式如下：
    new (address) ClassConstruct(...)
```

address表示已经存在的内存地址，该内存可以在栈上，也可以在堆上；

exp

```cc
//string s;
U(){new(&s) string;}
~U(){s.~string();}
```

联合体U内定义了一个不具名的联合体，该联合体包含了一个int类型的成员变量，我们称这个联合体为匿名联合体。

```cc
union U{
    union { int x; };  //此联合体为匿名联合体
};
```

**C++for循环详解（基于范围的for循环）**

```cc
for(declaration : expression){
    //tmod;
}
```

* declaration:表示此处要定义一个变量，该变量的类型要遍历序列中存储元素的类型。（可以用auto关键字）
* expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用	{ }   的初始化序列；

》在使用新语法格式for循环遍历某个序列时，如果要遍历同时修改序列中元素的值，实现方案是在declaration参数处定义引用形式的变量。

需要改变 元素值时用	& 	，否则使用const  &  （常引用）形式变量，（避免了底层复制变量的过程，效率更高。

* 使用for循环的注意事项；

  1）当使用for循环遍历时，无论该序列是普通数组、容器还是用{}大括号包裹的初始化列表，遍历序列的变量都表示的是当前序列中的各个元素

  2）基于范围的for循环还可以遍历普通数组、string字符串、容器以及初始化列表。除此之外，for循环冒号后还可以放置返回string字符串

  3）值得一提的是，当基于范围的for循环遍历的是某函数返回的string对象或者容器时，整个比遍历过程中函数只会执行一次，

  4）系统学习过STL标准库的读者应该知道，基于关联 式容器（包括hash容器）底层存储的机制：

  * 不允许修改map，unordered_map、multimap以及unodered_multimap容器的键值；
  * 不允许修改set、unordered_set、multiset以及unordered_multiset容器中存储的元素值。

**C++11 constexpr：验证是否为常量表达式**

》所谓常量表达式。指的是由对个常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这意味着，常量表达式的值一旦确定，其值将无法修改。

》constexpr的功能是使得指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到运行阶段。c++11中constexpr可用于修饰普通变量、函数（包括函数模板）以及类的构造函数。

constexpr是否会执行还要看编译器；

constexpr修饰普通变量时，变量必须经过初始化并且是一个常量表达式。

constexpr修饰函数：constexpr还可以修饰函数的返回值，这样的函数又称为

“常量表达式函数，必须满足以下4个条件：

1）整个函数体中，除了可以包含using指令、typedef语句以及static_assert断言外只能包含一条return语句。

2）该函数必须有返回值，即函数返回值不能是void。

3）函数使用之前必须有对应的定义语句。

4）return返回的表达式必须是常量表达式。

》constexpr修饰类的构造函数

对于C++内置的类型可以直接用constexpr修饰，但如果是自定义的数据类型（用struct或者class实现），直接用constexpr修饰是不行的。

constexpr修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。

（不支持用constexpr修饰带有virtual的成员方法。）

​	》constexpr修饰函数模板；

当constexpr修饰函数模板时，结果符合就是常量表达式，结果不符合，关键字就无效。

**constexpr和const**

const修饰的变量没有立即进行初始化时，表示数据是只读的，而const初始化已经赋值的变量表示该变量是一个右值，此时最好用constexpr来修饰。

***右值引用C++11***

C++右值引用指的是以引用传递（而非值传递）的方式使用C++右值。

》和声明左值一样，右值引用也必须立即进行初始化操作且只能使用右值进行初始化。右值引用还可以对右值进行修改

***C++移动构造函数详解***

》当类中包含了指针类型的成员变量，使用其他对象类初始化同类对象时，怎样才能避免深拷贝导致的效率问题。所以引入了移动语义。

》移动语义指的是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解是，移动语义指的是将其他对象的内存资源移为己用。

》事实上，对于程序执行过程中产生的零时对象，往往只用于传送数据（没有其他用处），并且会很快被销毁。因此在使用零时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。

》当类中同时包含拷贝构造函数和移动构造函数时，如果使用零时对象初始化当前类的对象，编译器会优先调用移动构造函数1来完成此操作。只有类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。

》左值初始化对象时适用移动构造函数。右值初始化对象时，用拷贝构造函数；

**C++11 move（）函数：将左值强制转换为右值**

》移动构造函数的调用时机是：用同类的右值对象初始化新对象。

》move将某个左值强转回右值

```cc
move(arg)
```

***C++11完美转发及实现方法***
》完美转发：指的是函数模板可以将自己的参数“完美”地转发给内部调用的其他函数。所谓完美，即不仅能准确的转发参数的值，还能保证被转发参数的左右值属性不变。

》总的来说，在定义模板函数时，我们采用右值引用的语法格式定义参数类型，由此该函数即可以接收外界传入的左值，也可以接收传入的右值；而且C++11标准库提供的forword（）模板函数修饰被调用函数中需要维持左、右值属性的参数。由此可实现完美转发。









***C语言内存分配***

在进程的地址空间中，代码区，常量区，全局数据区的内存在程序启动时就已经分配好，他们大小固定；不能由程序员分配和释放，只能等到程序运行结束时由操作系统回收。这称为静态内存分配。

栈区和堆区的内存分配是在程序运行时自动分配和释放的。这称为内存的动态分配和释放。动态内存分配。

**malloc函数背后的实现原理——内存池**

不管具体的分配算法是怎样的，为了减少系统调用，减少物理内存碎片，malloc的整体思想是先向操作系统申请一块大小适当的内存进行管理，这就是内存池。

（memory pool）

**规避野指针**（指向没有访问权限或者已经释放的区域）

1）指针变量如果暂时不需要赋值，一定要初始化为NULL。因为指针变量被创建时缺省值是随机的。

2）当指针直向的内存被释放时，也要置为NULL；

**内存泄漏**（memory leak）

程序和未释放内存失去了联系；（有malloc就要有free）

**存储类别和生命周期**

​	除了数据类型，变量还有一个属性称为存储类别。常量区全局数据区栈区。

》常量区和全局数据区的内存在程序启动时就已经由操作系统分配好，占用的空间固定，程序运行期间不在改变，程序运行结束后由操作系统释放；他可以存放全局变量，静态变量，一般常量和字符串常量，

》栈区的内存根据程序运行期间由系统根据需要分配（使用到变量时才分配内存；如果定义了变量但没有执行到该代码，也不会分配内存），占用的空间实时改变，使用完毕后立即释放，不必等到程序运行结束；他可以存放局部变量和函数参数等。

》C语言共有4个关键字用来指明存储类别：auto（自动的）、static（静态的）、register（寄存器的）、external（外部的）。

》知道变量的存储类型就知道了变量的生存期。

auto：自动的。加不加都一样，很少用；

static：声明变量为静态变量，不管他是不是全局，都存储在静态数据区。（只能初始化一次）；以后只能改变他的值；

register：寄存器存储变量；























































***C++输入输出流***

![img](http://c.biancheng.net/uploads/allimg/180831/1-1PS1153301321.jpg)

》图中的各个箭头代表各类之间的派生关系。iOS是所有流的基类，他派生出istream和ostream。为了避免多继承的二义性，从iOS派生出的istream和ostream时。均使用了virtual关键字（虚继承）；

图一中各个流的功能；

istream：常用于接收键盘的数据；

ostream：常用于将数据输出到屏幕上；

ifstream：读取文件中的数据；

ostream：用于像文件中写入数据；

iostream：继承自istream和ostream的类，既能用于输入也能用于输出；

fstream;既能像文件中写入数据也能从文件中读出数据；

》cout支持重定向，cerr和clog不支持重定向，只能输出到屏幕；cout和clog都有缓冲区；但是cerr没有缓冲区，会直接输出到屏幕上；（内置对象）

















**C++输入流对象常用成员方法**

》getline（str,n,ch）:从输入流中接收n-1个字符给str变量，当遇到指定ch字符使会停止读取，默认情况下ch为\0.





***设计模式***

Sigleton（单例模式）

》保证一个类仅有一个实例，并提供该实例的一个全局访问点。

Sinngleton

static instance()             return uniqueInstance；

SingletonOperation()

GetInstance()



static uniqueInstance

singletondata

```cc
class Singleton{
private:
    Singleton();
    Singleton(const Singleton& other);
    //构造函数和拷贝构造函数设置为私有；
public:
    static Singleton* getInstance();
    static Singleton* m_instance;
    //一个new创建Singleton对象
    //一个供外界调用的获取Singleton对象的静态函数；
}
Singleton* Singleton::m_instance=nullptr;//类外初始化

// 线程非安全版本
Singleton* Singleton::getInstanse(){
    if(m_instance==nullptr){//thread A 和thread B都进入这个位置
        m_instance=new Singleton;
    }
    return m_instance;
}

//线程安全版本；但锁的代价过高
Singleton* getInstance(){
    Lock lock;
    if(m_instance==nullptr){
        m_instance=new Singleton();
    }
    return m_instance;
}
//双检查锁，但是内存读写reorder不安全
//什么是reorder，new操作的正常顺序
				1）分配内存
                 2）调用构造函数；
                    3）给m_instance赋值
               实际可能顺序（reorder（编译器优化））
                1）分配内存
                2）给m_instance赋值(此时thread B判断后以为已经得到对象模型，实际上对象还未创建)
                3）调用构造函数；
Singleton* Singleton：：getInstance(){
    if(m_instance==nullptr){
        Lock lock;//两个线程进入，一个等待执行，一个执行，
        if(m_instance==nullptr)【
            m_instance= new Singleton();
    }
    return m_instance;
}


//c++11版本后的跨平台实现 线程安全单例模式
std::automic<Singleton> Singleton::m_instance;
std::mutex Singleton::m_mutex;

Singleton* Singleton::getInstance(){
    Singleton* tmp=m_instance.load(std::memory_order_relaxed);
    std::atomic_thread_fence(std_memory_order_acquire);
    if(tmp==nullptr){
        std::lock_guard<std::mutex> lock(m_mutex);
        tmp=m_instance.load(std::memory_order_relaxed);
        if(tmp==nullptr){
            tmp=new Singleton();
            std::stomic_thread_fnece(std::memory_order_relaxed);
        }
    }
    return tmp;
}
```

