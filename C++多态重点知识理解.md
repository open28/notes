***C++多态重点知识理解***

* 带虚函数的多重继承

  1）每个基类都有自己的虚函数表

  2）派生类如果有自己的虚函数会加入到第一个虚函数表之中；

  3）内存布局中，其基类的布局按照基类被声明的顺序进行排列；

  4）派生类会覆盖基类的虚函数，只有一个虚表中存放的是真实的被覆盖的函数的地址；其他虚函数表中存放的并不是真实的对应的虚函数的指针而是一条跳转到虚函数地址的指针；

  **多基派生的二义性**

  **虚拟继承**

  采用虚函数关键在于，存在、间接和共享，三个特性

  虚函数时存在的；

  虚函数必须要通过一种间接的运行时（而不是编译时）机制才能够激活（调用）的函数。

  共享性表现在虚基类会共享被派生类重定义的函数；

  虚拟继承如何表现这三种特性：

  * 存在表示虚继承体系和虚基类确实存在；
  * 间接性表现当访问虚基类成员时必须通过某种间接机来完成（通过虚基表来完成；
  * 共享性表现在基类会在继承体系中被共享，而不是出现多份拷贝；

* 单个虚继承不带虚函数

  多了一个虚基指针；

  虚基类位于派生类存储空间最末尾；

* 单个虚继承带虚函数

  如果派生类没有自己的虚函数，此时派生类对象不会产生虚函数指针

  如果派生类拥有自己的虚函数，此时派生类会产生自己本身的虚函数指针，并且该虚函数指针位于派生类对象存储空间的开始位置。

**虚拟继承时派生类对象的构造和析构**

* 在C++继承链上存在虚继承的基类，则最底层的子类要完成该虚基类部分成员的构造。必须要在最底层的子类显示调用虚基类的构造函数。如果不显示调用就会调用缺省构造函数，如果虚基类没有定义缺省构造函数，则会编译出错。因为如果不这样，虚基类部分会在存在多个继承链上被多次初始化。

**菱形继承**

* 虚基指针所指的虚基表的内容

  1）虚机指针的第一条内容指定是该虚基指针基类所在子对象的首地址的偏移

  2）虚基指针的第二条内容时虚基指针距离虚基类子对象大首地址的偏移

  》有继承的时候，派生类被创建的时候，只有该派生类列出的虚基类的构造函数被调用，其他类列出的将被忽略；

  》对于虚继承的派生类的析构，析构函数的调用顺序为：

  * 先调用派生类的析构函数；
  * 然后调用派生类中成员对象的析构函数；
  * 在调用普通基类的析构函数；
  * 最后调用虚基类的析构函数。

***效率分析***

访问效率主要体现在两个方面；对象构造时，vptr的多次设定，以及this指针的调整。对于多继承的情况效率对比如下：（多重继承和虚拟继承）

》多重继承：指针对象引用访问对象效率相同，通过vptr和vtable访问：通过第二或后继Base类指针访问。需要调整this指针，除了多态的引入，带来了设定vptr和间接访问虚函数的效率降低。调整this指针也会带来效率的降低；

》虚拟继承：指针、对象、引用访问效率降低，通过vptr和vtable访问；访问虚基类需要调整this指针。



