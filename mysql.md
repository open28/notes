```mysql
select * from emp;

select ename,sal from emp;

select ename,sal*12 (as)`annule sal` from emp;#

select ename,sal*12+(case when come is NULL then 0 else come end)
annual_sal from emp;

select distinct deptno,job from emp;

 select * from emp where sal between 
 
 
 
 select ename from emp join
 (select emp,max(sal)  max_sal from emp group by depton) t
 where emp.deton = t.depton and
 emp.sal=t.max_sal;
 
 select xx from biaoming;
 where 对数据进行过滤；
 group by 分组；
 having 对分组进行限制
 order by 排序



select avg(sal) from emp where sal>1200//这是一张表
group by depton//对结果进行分组
having avg(sal)>1500//分组之后，平均薪水大于1500
order by avg(sal) desc;//平均薪水倒叙排列


子查询把查询结果看成一张表
select ename,sal from where sal>(select avg(sal) from emp);

select


left join //把左边的表中多余的数据取出来
right join //把右边的表中多余的数据取出来
select e1.ename emp,e2.ename mgr from emp e1 left join emp e2 on e1.mgr =e2.empno;
```

***主键索引***

show index from tablename;#查看索引

alter table tablename add primary key(filed_name);#添加主键索引

**普通索引**

create index index_name on table_name(files_name);#创建普通索引

alter table table_name add index index_name(field_name);#添加普通索引

**唯一索引**

与普通索引类似，不同的是唯一索引要求所有的类的值是唯一的，这一点和主键索引一样，但是他允许有空值

create unique index index_name on table(filed);

**组合索引**

一个表中包含多个单列索引不代表是组合索引，通俗一点讲组合索引是：包含了多个字段，但是只有索引名称

create index index_name add  on table(field1,field2,......);

alter table mytable add index name_city_age(name,city,age);

为了进一步榨取Mysql的效率，就要考虑组合索引

**删除索引**

alter table  table_name drop index index_name;

drop index index_name on tablename;

**索引的好处和坏处**

好处

* 提高数据检索的效率，降低数据库IO的成本。
* 查找排序分组
* 表的连接

坏处

* 占用额外的空间，有时候索引占用的空间甚至比数据占用的还要多。
* 虽然索引大大提高了查询速度，但同时也降低了更新表的速度。因为数据库不仅要更新数据，还要更新索引信息。
* 索引不是越多越好，索引太多，应用程序的性能可能会受到影响；索引太少，查询速度变慢，我们应该建立合适的索引，找到一个平衡点！

**最左前缀**

***MySQL优化***

大体来说MySQL可以分为sever层和存储引擎层。

server层包括、连接器、查询缓存、解析器、优化器和执行器等，涵盖了MySQL的大多数核心功能。

存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持innodb，myisam、memory等多个存储引擎。

**存储引擎**

show engines;#支持哪些存储引擎

show variables like '%storage_engine%';#查看默认存储引擎

```mysql
SELECT ENGINE FROM information_schema(表名) TABLES
WHERE TABLE_SCHEMA='$db'
AND TABLE_NAME='$table';
```

MyISAM

MySQL5.5之前默认的存储引擎

特点：

* 查询速度很快
* 支持表锁
* 支持全文索引
* 不支持事务

使用myisam会生成三个文件。

。frm#存储表的结构，任何引擎都有

。myd# 存放数据

。myi#存放索引

索引和数据分开存放，这样的索引叫做非聚集索引

Innodb

mysql5.5之后的搜索引擎。没有特殊应用，推荐使用innodb引擎。

* 支持事务
* 支持行锁和表锁
* 支持mvcc
* 支持崩溃恢复
* 支持外键一致性约束

使用innodb会生成两个文件。

。frm#存储表结构，任何引擎都有

。idb存储数据和索引

》索引和数据存放在一起的叫聚集索引

memory

特点：

* 所有数据都存放在内存中，因此数据库重启后数据会丢失
* 支持表锁
* 支持hash和Btree索引
* 不支持blob和text字段

memory由于数据都在内存中，以及支持hash索引，他的查询速度时最快的。

一般用memory存放零时表。

零时表：在单个连接中可见，当连接断开时，零时表也不复存在。

![image-20210607225622990](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210607225622990.png)

为什么需要锁？锁的概念

使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾

锁的概念：

​	锁是计算机协调多个进程或线程并发访问某一资源的机制。

在数据库中，数据也是一种供多用户共享的一种资源。如何保证数据并发访问的一致性、有效性是数据库所必须解决的问题，锁冲突也是影响数据库并发访问性能的一个重要因素。

mysql的锁机制比较简单，其最显著的特点是，不同的存储引擎支持不同的锁机制。

》比如，myisam中的锁机制比较简单，采用的是表级锁（table-level locking）；BDB采用的是页面锁，但也支持表级锁（page-level   locking）。innodb存储引擎既支持也支持行级锁也支持表级锁，但是默认情况下，但是默认采用行级锁。

***锁的分类***

mysql大致可以分为以下几类：

* 表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低
* 行级锁：开销大，加锁慢：会出现死锁：锁定粒度最小，发生锁冲突的概率最顶，并发度最高。
* 读锁（共享锁）
* 写锁（排它锁）当操作没有完成之前，会阻断其他读锁和写锁。

Myisam的表锁

》在执行select语句前，会自动给涉及的表加读锁，在执行更新操作前（updata，delete，insert）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要用lock  table命令给myisam表显示加锁。

用法：

**lock table table_name read**;

**lock table table_name write**;

**unlock  tables**

**show open tables**;

》加读锁的进程可以读加锁的表，但不能读其他表

》加读锁时，其他进程update加读锁的表会一直处于等待锁的状态，直到锁被释放后才会update成功。

》读锁会阻塞写，但不会阻塞读，写锁会阻塞读和写 

***业务设计***

逻辑设计：

* 范式设计
* 饭范式设计

物理设计

* 命名规范
* 存储引擎选择
* 数据类型选择

范式设计

》为了建立冗余较小，结构合理的数据库，设计数据库时必须要遵循一定的规则。在关系型数据库中这中这种规则被称为范式。范式时符合某一设计要求的总结。要想设计一个合理的数据结构必须满足一定的范式。

**数据库设计的三大范式**

》第一范式（确保每列的原子性）

》第二范式（确保表中的每列都和主键相关）

所有非主键字段完全依赖主键，不能产生部分依赖。

多对多：三张表，关系表中用外键建立另外两张表的联系

》第三范式（确保每列都和主键直接相关）

范式设计的优点：

* 可以尽量减少数据冗余
* 范式化设计的表通常比反范式设计的表更小
* 范式化的数据更新更快

不足：

* 范式化的表在查询时通常需要join很多关联，增加查询的代价。
* 更难进行所有优化

》完全符合范式设计有时候并不能得到很好的sql查询性能

**反范式设计**

允许存在少两冗余，换句话说反范式化就是使用空间来换取时间

优点：

* 可以减少表的关联
* 可以更好的进行索引优化

缺点;

* 存在数据冗余及数据维护异常
* 对数据的修该需要更多的成本

**物理设计**

* 定义数据库。表及字段的命名规范

  （可读性，表意性，长名原则）

* 选择合适的收缩引擎

  提供提交，回滚和恢复的事务安全（acid兼容）能力，要求实现并发控制，innodb是一个很好的选择

  如果数据表只用来插入和查询，则myisam引擎提供较高的处理效率。

  如果只是存放零时表，数据量不大，并且不需要较高的数据安全性，可以选着将数据保存在memory引擎中。

* 为表中的字段选择合适的数据类型

  优先考虑数字类型

  其次是日期时间类型

  最后时字符类型

  对于同级别的数据类型，应优先选择占用空间小的数据类型

* 建立数据库结构

***索引***

索引时为了提高数据的查询效率，就像书的目录一样，

索引在MySQL中也叫键（key），是存储引擎用于快速找到记录的一种数据结构。

**哪些结构可以作为索引**

* 有序数组

* 哈希表

* 平衡二叉树（O（logn）），数据量较大时，IO次数比较多。

* B树

  B树，他是一颗多路平衡查找树，我们描述一颗B树需要指定他的阶数，阶数表示了一个结点最多有多少个孩子，一般用字母m表示。一颗m阶B树的定义：

  * 除根节点外每个结点最多有m-1个关键字，至少有（m/2）-1个关键字
  * 根节点可以有一个关键字，最多有m-1关键字
  * 每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中所有关键字都小于他，而右子树中的所有关键字都大于他。
  * 所有叶子结点都位于同一层，或则说根节点到叶子结点的路径长度都相同。

  索引和数据存放在一起；

* B+树索引

  * B+树包含两种类型的结点：内部结点（也称索引结点）和叶子结点。根结点即可以是内部结点也可以是叶子结点。根结点既可以是内部结点也可以是叶子结点，根节点的关键字个数可以只有一个
  * B+树与B树最大的不同是内部结点不保存数据，只保存索引，所有的记录都在叶子结点中。
  * m阶B+树表示了内部最多有m-1个关键字。至少有m/2-1个关键字。
  * 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的额一个key，左树中的所有key都小于他，右子树中的所有结点都大于他。叶子结点中也按照key的大小排列。
  * 每个叶子结点都存有相邻叶子结点的指针，叶子结点关键字大小依次连接。

而且由于叶子结点是由链表按大小依次连接的（在innodb是双向链表）。范围查找的时候也可以避免多次IO次数。

***索引的好处和坏处***

好处：

* 查找
* 排序
* 分组
* 表的连接

坏处：

* 占用额外的空间。有时候索引暂用的空间甚至比数据占用的空间还多。
* 虽然索引大大提高了查询速度，但是也降低了更新表的速度。因为数据库不仅仅要更新数据，还要更新对应的索引信息。

**辅助索引**

对于辅助索引，叶子结点不包含行记录的全部数据，叶子结点除了包含键以外，还包含聚集索引的键，也就是主键的信息。

辅助索引的存在并不影响数据在聚集索引的组织，因此每张表可以有多个辅助索引。

**回表**

当通过辅助索引来寻找数据的时候，InnoDB会遍历辅助索引，并通过辅助索引的叶子节点，获取主键。然后再通过聚集索引来找到一个完整的行记录。这个过程我们称之为回表。

》如果一个辅助索引的高度为3，聚集索引的高度为3。那么我们需要6次IO操作，才可以访问最终的数据。

**联合索引**

联合索引指的是对表的多个列进行索引。

联合索引的键都是按照（a，b）的顺序进行存放的。

联合索引的第二个好处是：键是已经排好序的。

覆盖索引（索引覆盖）

innodb存储引擎支持覆盖索引（covering index），即从辅助索引中就可以得到要查询的信息，而不需要回表。

***为什么查询速度很慢***

ü查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是整个生命周期中最重要的阶段，其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。（慢查询日志）

***启动慢查询日志***

Show variables like “%slow_query_log”;

Set global slow_query_log=1; #只是临时生效，如果要永久生效，必须修改配置文件

show variables like "%long_query%"; 

Set global long_query_time=0.1; #为什么修改之后看不到变化？

需要重新连接或者show global variables like ‘long_query%’

可以select sleep(1);

Show global status like ‘%slow_queries’; #查看慢查询SQL记录数

![image-20210608102535018](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210608102535018.png)

id:相同，执行计划有上至下，

id不同，id值越大，优先级越高，越先被执行

| **类型**      | **描述**                                                     |
| ------------- | ------------------------------------------------------------ |
| SIMPLE        | 简单的  select 查询,查询中不包含子查询或者UNION              |
| PRIMARY       | 查询中若包含任何复杂的子部分，最外层查询则被标记为           |
| SUBQUERY      | 在SELECT或WHERE列表中包含了子查询                            |
| DERIVED       | 在FROM列表中包含的子查询被标记为DERIVED(衍生)  MySQL会递归执行这些子查询,  把结果放在临时表里。 |
| UNION         | 若第二个SELECT出现在UNION之后，则被标记为UNION；  若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED |
| UNION  RESULT | 从UNION表获取结果的SELECT                                    |

**执行计划——type**

syetem>const>eq_ref>ref>range>index>all

* system:系统表，少量数据，往往不需要进行磁盘IO
* const：常量连接
* eq_ref:主键索引或者非空唯一索引
* ref：非主键非唯一等值扫描
* rang：范围扫描
* index；索引树扫描
* all：全表扫描

**执行计划-key_len**

* 表示索引中使用的字节数，可以通过该列计算查询使用索引的长度，
* 显示索引字段的最大可能长度，
* 可以根据长度判断索引使用的情况，特别是在组合索引的时候，判断所有的索引字段是否都被查询用到。

uchar和varchar跟字符编码也有密切的联系,latin1占用1个字节，gbk占用2个字节，utf8占用3个字节（不同字符编码占用的存储空间不同）。

u允许为NULL的字段需要额外一个字节记录

 key_len = n**长度+ 允许为NULL = 1*20 + 1 = 21

**何时创建索引**

* 主键和唯一键会自动创建索引，外键要求必须是primary key或者unique
* 频繁作为查询条件的字段
* 与其他表关联的字段。
* 查询中用于排序的字段
* 查询中用于分组的字段

**何时不应该创建索引**

* 表的记录太少
* 经常更行表
* 数据字段中包含太多重复值

**实践策略**

* 对于辅助索引，尽量使用覆盖索引（避免回表）
* 尽量使用最左法则
* 不要在索引列上做运算
* 范围查找尽量不要太大
* 尽量不要使用不等于



***一些规范***

* 尽量使用innodb存储引擎
* 禁止存储大文件或者存储大照片
* 控制单表数据量，单表数据在千万级
* 平衡范式和冗余
* 表必须有主键，
* 必须把字段定义为NOT NULL 并且提供默认值
* 禁止使用TEXT，BLOB类型
* 根据业务区分使用char/varchar
* 单表索引建议控制在5个以内
* 禁止在更行十分频繁，区分度不高的属性上建立索引
* 一些组合索引，必须把区分度高的字段放在前面
* 理解组合索引最左前缀原则，避免重复建设索引，如果建立了（a，b，c）相当于建立了(a),(a,b)(a,b,c)
* 禁止使用select*，只获取必要字段，需要显示说明列属性
* sql where条件的顺序不一定需要按照索引的顺序

